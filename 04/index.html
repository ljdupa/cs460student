<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background: url('https://cs460.org/assignments/04/bg.jpg') center/cover no-repeat fixed;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }

      #c {
        width: 100%;
        height: 100%;
        background: transparent;
        display: block;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="x-shader/x-vertex">
    attribute vec3 a_position;

    uniform float u_dir;
    uniform float u_pointsize;
    uniform mat4  u_transform;

    void main(void) {
        vec3 p = a_position;
        p.x *= u_dir;                    // mirror left/right

        gl_Position = u_transform * vec4(p, 1.0);  // matrix does scale+rotate+translate
        gl_PointSize = u_pointsize;
    }
    </script>
  
  <script id="fragmentshader" type="x-shader/x-fragment">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

    let c, gl, shaderprogram, u_pointsize, u_transform;
    let all_fish = [];

    window.onload = function() {
        

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      if (!gl) {alert ('WebGL not available'); return; }
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );
      u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
      u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


      // create multiple fish
      all_fish = [];
      all_fish.push(
        createFish(new Float32Array([0,0,0]),
           new Float32Array([1, 0, 0, 0.8]),  // 0.8 alpha
           new Float32Array([1,1,1]),
           1.0));
      for (let i = 0; i < 100; i++) {
  const random_color = new Float32Array([
  Math.random(), Math.random(), Math.random(), 0.6 + Math.random()*0.25 // 0.6..0.85 alpha
]);

  // keep them mostly on-screen
  const random_offset = new Float32Array([
    (Math.random() * 1.8) - 0.9, // x in [-0.9, 0.9]
    (Math.random() * 1.8) - 0.9, // y in [-0.9, 0.9]
    0.0
  ]);

  const s = Math.random() * 0.3 + 0.05;          // size in (0.05 .. 0.35)
  const random_scale   = new Float32Array([s, s, 1.0]);
  const random_dir     = Math.random() < 0.5 ? -1.0 : 1.0;

  all_fish.push( createFish(random_offset, random_color, random_scale, random_dir) );
}

    // Convert ~15% of the small fish into trash (skip the big red one at index 0)
for (let i = 1; i < all_fish.length; i++) {
  if (Math.random() < 0.15) {
    const [, , , , offset, scale, dir] = all_fish[i];
    // dingy plastic/metal look with decent alpha
    const trashColor = new Float32Array([
      0.7 + Math.random()*0.2,  // a bit off-white/gray
      0.7 + Math.random()*0.2,
      0.6 + Math.random()*0.2,
      0.8
    ]);
    all_fish[i] = createTrash(offset, trashColor, scale, dir);
  }
}

      animate();

    };



    function createFish(offset, color, scale = new Float32Array([1, 1, 1]), direction = 1.0) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
      var vertices = new Float32Array([
                                     0.5,  0, 0, // 0: nose
                                     0.2, 0.25, 0.0, // 1: upper body
                                     -0.2,  0.15, 0.0, // 2: upper tail base
                                     -0.4, 0.3, 0.0, // 3: upper tail tip
                                     -0.4, -0.3, 0.0, // 4: lower tail tip
                                     -0.2, -0.15, 0.0, // 5: lower tail base
                                     0.2, -0.25, 0.0 // 6: lower body
                                    ]); // 2 * 4 == 8 bytes

      // now use indices
      var indices = new Uint8Array([ 
        0, 1, 6, // main body
        1, 2, 6, // upper mid-body
        2, 5, 6, // rear body
        2, 3, 5, //tail top
        3, 4, 5 // tail fin
    ]); //

      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind


      var eye_vertex = new Float32Array([ 0.20, 0.20, 0.0]);
      var eye_v_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];

    };

var step_x = 0.01;
var step_y = 0.01;
var direction = -1;


// draw every frame
function animate() {
  requestAnimationFrame(animate);

  gl.clearColor(0.0, 0.0, 0.0, 0.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.enable(gl.BLEND);
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);

  for (var r = 0; r < all_fish.length; r++) {
    const [vbuf, ibuf, eye_vbuf, color, offset, scale, dir] = all_fish[r];

    // bounce update
    offset[0] += 0.01;                               // steady rightward swim
    offset[1] += 0.1 * (Math.random() - 0.5);        // small vertical wiggle

    if (offset[0] >= 1.0) {                          // wrap to the left
    offset[0] = -1.0;
}

    // bind geometry
    gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibuf);

    const a_position = gl.getAttribLocation(shaderprogram, 'a_position');
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);

    // uniforms
    const u_color = gl.getUniformLocation(shaderprogram, 'u_color');
    const u_dir   = gl.getUniformLocation(shaderprogram, 'u_dir');

    // --- rotation (0..10 degrees) + per-fish scale folded into the matrix ---
    const theta = (Math.random() * 10.0) * Math.PI / 180.0;
    const cosT = Math.cos(theta), sinT = Math.sin(theta);
    const sx = scale[0], sy = scale[1], sz = scale[2];  



    // Column-major mat4: Rz(theta) * S(sx,sy,sz) with translation by offset
    const transform = new Float32Array([
        cT*sx,  sT*sx, 0, 0,
       -sT*sy, cT*sy, 0, 0,
        0,        0,       1*sz, 0,
        offset[0] + wobbleX, offset[1] + wobbleY, 0, 1
    ]);
    gl.uniformMatrix4fv(u_transform, false, transform);

    let current_color;

    if (r === 0) {
    // big fish stays red
    current_color = new Float32Array([1.0, 0.0, 0.0, 0.7]);
    } else {
        const t = performance.now() * 0.002;         // seconds
        const alpha = 0.6 + 0.4 * Math.sin(t * 2.0 + r); // 0.2..1.0, phase per fish
        current_color = new Float32Array([color[0], color[1], color[2], alpha]);
    }

    // send color for the body this frame
    gl.uniform4fv(u_color, current_color);
    gl.uniform1f(u_dir,   dir);

    // draw body (5 triangles = 15 indices)
    gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

    // draw eye (POINT) — only if this is a fish (eye_vbuf exists)
    if (eye_vbuf) {
        gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.5]));
        const pointScale = Math.max(scale[0], scale[1]);
        gl.uniform1f(u_pointsize, pointScale * 20.0);

        gl.bindBuffer(gl.ARRAY_BUFFER, eye_vbuf);
        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_position);
        gl.drawArrays(gl.POINTS, 0, 1);
        let localTheta = theta;

        let wobbleX = 0, wobbleY = 0;
        if (!eye_vbuf) {              // this is trash
            const tt = performance.now() * 0.001 + r;
            localTheta = 0.3 * Math.sin(tt * 0.7); // slow, small spin
            wobbleX = 0.02 * Math.sin(tt * 1.3);   // tiny drift
            wobbleY = 0.02 * Math.cos(tt * 1.1);
        }
        const cT = Math.cos(localTheta), sT = Math.sin(localTheta);
    }
  }
}


function createTrash(offset, color, scale = new Float32Array([1,1,1]), direction = 1.0) {
  // a small “bag/can” silhouette (two quads + a tiny notch) in NDC-ish local space
  const vertices = new Float32Array([
    // body quad
    -0.15, -0.20, 0.0,
     0.15, -0.20, 0.0,
     0.15,  0.20, 0.0,
    -0.15,  0.20, 0.0,

    // top “crumple” / tab (small triangle on top-left)
    -0.10,  0.20, 0.0,
    -0.20,  0.28, 0.0,
    -0.02,  0.26, 0.0,
  ]);

  const indices = new Uint8Array([
    // body (two triangles)
    0, 1, 2,
    0, 2, 3,
    // tab
    4, 5, 6,
  ]);

  const v_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, v_buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  const i_buffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i_buffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  // NOTE: eye_v_buffer = null marks this as “trash”
  return [v_buffer, i_buffer, null, color, offset, scale, direction];
}



  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
