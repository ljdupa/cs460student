<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform float u_dir;
    uniform float u_pointsize;
    uniform mat4  u_transform;

    void main(void) {
        vec3 p = a_position;
        p.x *= u_dir;                    // mirror left/right

        gl_Position = u_transform * vec4(p, 1.0);  // matrix does scale+rotate+translate
        gl_PointSize = u_pointsize;
    }
    </script>
  
  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;
    var u_pointsize, u_transform;

    window.onload = function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );
      u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
      u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


      // create multiple fish
      all_fish = [];
      all_fish.push(
        createFish(
            new Float32Array([0, 0, 0]),
            new Float32Array([1, 0, 0, 1]),
            new Float32Array([1, 1, 1]),
            1.0
        )
      );
      for (let i = 0; i < 100; i++) {
  const random_color  = new Float32Array([
    Math.random(), Math.random(), Math.random(), 1.0
  ]);

  // keep them mostly on-screen
  const random_offset = new Float32Array([
    (Math.random() * 1.8) - 0.9, // x in [-0.9, 0.9]
    (Math.random() * 1.8) - 0.9, // y in [-0.9, 0.9]
    0.0
  ]);

  const s = Math.random() * 0.3 + 0.05;          // size in (0.05 .. 0.35)
  const random_scale   = new Float32Array([s, s, 1.0]);
  const random_dir     = Math.random() < 0.5 ? -1.0 : 1.0;

  all_fish.push( createFish(random_offset, random_color, random_scale, random_dir) );
}

      animate();

    };


    function createFish(offset, color, scale = new Float32Array([1, 1, 1]), direction = 1.0) {


      //************************************************************//
      //
      // CREATE GEOMETRY
      //
      var vertices = new Float32Array([
                                     0.5,  0, 0, // 0: nose
                                     0.2, 0.25, 0.0, // 1: upper body
                                     -0.2,  0.15, 0.0, // 2: upper tail base
                                     -0.4, 0.3, 0.0, // 3: upper tail tip
                                     -0.4, -0.3, 0.0, // 4: lower tail tip
                                     -0.2, -0.15, 0.0, // 5: lower tail base
                                     0.2, -0.25, 0.0 // 6: lower body
                                    ]); // 2 * 4 == 8 bytes

      // now use indices
      var indices = new Uint8Array([ 
        0, 1, 6, // main body
        1, 2, 6, // upper mid-body
        2, 5, 6, // rear body
        2, 3, 5, //tail top
        3, 4, 5 // tail fin
    ]); //

      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind


      var eye_vertex = new Float32Array([ 0.20, 0.20, 0.0]);
      var eye_v_buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer);
      gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];

    };

var step_x = 0.01;
var step_y = 0.01;
var direction = -1;


// draw every frame
function animate() {
  requestAnimationFrame(animate);

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  for (var r = 0; r < all_fish.length; r++) {
    const [vbuf, ibuf, eye_vbuf, color, offset, scale, dir] = all_fish[r];

    // bounce update
    offset[0] += 0.01;                               // steady rightward swim
    offset[1] += 0.1 * (Math.random() - 0.5);        // small vertical wiggle

    if (offset[0] >= 1.0) {                          // wrap to the left
    offset[0] = -1.0;
}

    // bind geometry
    gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibuf);

    const a_position = gl.getAttribLocation(shaderprogram, 'a_position');
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);

    // uniforms
    const u_color = gl.getUniformLocation(shaderprogram, 'u_color');
    const u_dir   = gl.getUniformLocation(shaderprogram, 'u_dir');

    // --- rotation (0..10 degrees) + per-fish scale folded into the matrix ---
    const theta = (Math.random() * 10.0) * Math.PI / 180.0;  // small spin each frame
    const c = Math.cos(theta), s = Math.sin(theta);

    const sx = scale[0], sy = scale[1], sz = scale[2];       // this fish's size

    // Column-major mat4: Rz(theta) * S(sx,sy,sz) with translation by offset
    const transform = new Float32Array([
      c*sx,  s*sx, 0, 0,
     -s*sy,  c*sy, 0, 0,
      0,     0,    1*sz, 0,
      offset[0], offset[1], 0, 1
    ]);
    gl.uniformMatrix4fv(u_transform, false, transform);

    // remaining uniforms
    gl.uniform4fv(u_color, color);
    gl.uniform1f(u_dir,   dir);

    // draw body (5 triangles = 15 indices)
    gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

    // draw eye (POINT)
    gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.5])); // semi-transparent black
    const s = Math.max(scale[0], scale[1]);
    gl.uniform1f(u_pointsize, s * 20.0);

    gl.bindBuffer(gl.ARRAY_BUFFER, eye_vbuf);
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);
    gl.drawArrays(gl.POINTS, 0, 1);
  }
}



  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
